# 968. 监控二叉树
给定一个二叉树，我们在树的节点上安装摄像头。

节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。

计算监控树的所有节点所需的最小摄像头数量。

示例 1：

![img](q968img1.png)

输入：[0,0,null,0,0]
输出：1
解释：如图所示，一台摄像头足以监控所有节点。

示例 2：

![img](q968img1.png)

输入：[0,0,null,0,null,0,null,null,0]
输出：2
解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。

提示：

给定树的节点数的范围是 [1, 1000]。
每个节点的值都是 0。

# 解题

## 贪心算法

设定3个状态
0 未监控， 1 已监控， 2 监控头

从底部递归上来
递归到叶子节点，叶子节点特点是左右指针空，要让叶子节点0

- 左节点0，右节点0，该节点设2
- 左节点0，右节点1，该节点设2
- 左节点0，右节点2，该节点设2
- 左节点1，右节点0，该节点设2
- 左节点1，右节点1，该节点设0
- 左节点1，右节点2，该节点设1
- 左节点2，右节点0，该节点设2
- 左节点2，右节点1，该节点设1
- 左节点2，右节点2，该节点设1

left==1&&right==1 return 0
left==0||right==0 return 2
left+right>=3 return 1

为保证叶子节点是0，让叶子dfs(left)时返回1,确保left==1&&right==1时 返回0


## 官方解法

状态 a：root 必须放置摄像头的情况下，覆盖整棵树需要的摄像头数目。
状态 b：覆盖整棵树需要的摄像头数目，无论 root 是否放置摄像头。
状态 c：覆盖两棵子树需要的摄像头数目，无论节点 root 本身是否被监控到。

a = lc + rc + 1;
b = min(a, min(la+rb, lb+ra))
c = min(a, min(lb+rb))




