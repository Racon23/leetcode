# 538. 把二叉搜索树转换为累加树
给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

例如：

输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
 

注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同


# 用例
```
[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
[10,6,15,2,8,11,18]
```

# 解题

二叉搜索树根据中序遍历左中右可以得到一个升序的有序数组

根据这个特性，反序中序遍历可获得降序数组，在遍历过程中累加即可


Morris 遍历
利用叶子节点的空指针，节省临时节点的空间。空间复杂度可达o(1)

反序中序遍历有以下步骤

如果 右节点空，处理节点，并移向左节点(此时该左节点指向父级节点)

如果 右节点不空。获取该右子树的最左节点(可以越多级)。

    如果最左节点的左指针空，将其指向当前节点。移向右节点
    
    如果最左节点的左指针不空，意味着该节点已经遍历了一次。处理当前节点，（此时为父节点）移向左节点.清空最左节点的左指针。

              10
            /   \
           6     15
         /   \  /   \
        2    8 11    18

总结，建指针时向右移动，处理时向左移动

1. 当前节点10，右节点15不空，获取最左节点11，左指针指向10。移向15
2. 右节点18不空，最左节点18自己，左指针指向15，移向18
3. 右节点空，处理18，移向左指针，返回15.
4. 15的右节点不空，但是最左节点已指向，清空最左节点左指针，处理15，移向左节点11。
5. 11的右节点空，处理。移向左指针，返回10。
6. 10的右节点不空，但是最左节点11已指向，清空最左节点左指针，处理10，移向左节点6。
7. 右节点8不空，最左节点8自己，左指针指向6，移向8
8. 右节点空，处理8，移向左指针，返回6.
9. 6的右节点不空，但是最左节点8已指向，清空最左节点左指针，处理6，移向左节点2。
10. 右节点空，处理2，移向左指针，空，结束。




